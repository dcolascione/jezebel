(require 'cl)
(require 'jezebel-util)
(require 'jezebel-tree)

;; (declare (optimize (speed 3) (safety 0)))


;;; ---------------------
;;; Parser infrastructure
;;; ---------------------
;;;
;;; Starting with a grammar description list, we create a jez-parser
;;; using JEZ-COMPILE.  The returned parser is a compressed and
;;; optimized representation of the input grammar, and it is logically
;;; immutable.  To parse a buffer using this parser, we create a
;;; jez-state instance using JEZ-BEGIN-PARSE.  We then call
;;; JEZ-ADVANCE on this parser state until it returns non-nil,
;;; indicating that we reached a terminal state.  The resulting AST,
;;; generated by side effect, may be extracted from the jez-state
;;; instance using JEZ-GET-AST.
;;;

(defstruct (jez-parser
            (:constructor jez--%make-parser)
            (:copier nil)
            (:conc-name jez-parser--))

  "Compiled representation of a grammar that can be used to
create jez-state that, in turn, parses buffers."

  ;; Initial state symbol for this parser.
  (initial-state nil)

  ;; Node names
  (node-names (make-hash-table)))

(defstruct (jez-state
            (:constructor jez--make-state)
            (:copier nil)
            (:conc-name jez-state--))

  "State of an ongoing parse."

  ;; Reach (buffer position)
  (reach 0)

  ;; Stack states to enter when backtracking
  (or-stack (make-vector 256 nil))
  (or-stack-pos 0)

  ;; Stack of states to enter when successful
  and-stack

  ;; The current AST
  (ast (jez-make-empty-tree)))

(defun* jez--double-vector (vec &optional init)
  "Return a copy of vector VEC of twice its length.  The additional
elements are set to INIT."
  (loop
   with new-vec = (make-vector (* (length vec) 2) init)
   for i from 0 to (length vec)
   do (setf (aref new-vec i) (aref vec i))
   finally return new-vec))

(defmacro jez--push-vector (vec-place pos-place item)
  "Add ITEM to the extensible vector given by VEC-PLACE and
POS-PLACE, expanding the vector if appropriate.

N.B VEC-PLACE and POS-PLACE may be evaluated more than once.
"
  `(progn
     (when (<= (length ,vec-place) ,pos-place)
       (assert (= (length ,vec-place) ,pos-place))
       (setf ,vec-place (jez--double-vector ,vec-place)))
     (setf (aref ,vec-place
                 (prog1 ,pos-place (incf ,pos-place)))
           ,item)))

(defmacro jez--pop-vector (vec-place pos-place)
  "Return and remove the value at the end of the extensible
vector given by VEC-PLACE and POS-PLACE."
  `(prog1
     (aref ,vec-place (decf ,pos-place))
     (assert (>= ,pos-place 0))))

(defun* jez-state-reach-forward (state new-reach)
  (jez-with-slots (reach) (jez-state state)
    (assert (>= reach (point-min)))
    (assert (>= new-reach (point-min)))
    (setf reach (max reach new-reach))))

(defun* jez-backtrack (state)
  "Back up to most recent choice point in STATE."
  (symbol-macrolet ((os (jez-state--or-stack state))
                    (osp (jez-state--or-stack-pos state)))
    (assert (> osp 0))
    (while (not (funcall (aref os (decf osp)) state)))))

(defun* jez-add-undo-1 (state item)
  "Add an undo record to STATE.

To backtrack, we pop the first item from STATE's or-stack and
call it as a function.  If this function returns nil, we repeat
the process.  The called function may pop additional values from
the or-stack."
  (jez--push-vector (jez-state--or-stack state)
                    (jez-state--or-stack-pos state)
                    item))

(defun* jez-add-undo (state &rest items)
  "Add ITEMS to STATE's undo stack.  The last item will be at the
top of the stack."
  (dolist (item items)
    (jez-add-undo-1 state item)))

(define-compiler-macro jez-add-undo (state &rest items)
  "Add entries to a state's undo stack."
  `(symbol-macrolet ((os (jez-state--or-stack state))
                     (osp (jez-state--or-stack-pos state)))
     (when (<= (+ osp ,(length items)) (length os))
       (setf os (jez--double-vector os)))
     ,@(loop for item in items
             collect `(aset os (incf osp) ,item))))
(put 'jez-add-undo 'lisp-indent-function 1)

(defun* jez-state-pop-undo (state)
  "Remove an entry from a state's undo stack and return it."
  (jez--pop-vector (jez-state--or-stack state)
                   (jez-state--or-stack-pos state)))

(defun* jez--undo-handle-choice-point (state)
  "Handle undoing up to a choice point."
  (jez-with-slots (and-stack) (jez-state state)
    (goto-char (jez-state-pop-undo state))
    (setf and-stack (jez-state-pop-undo state))
    t)                     ; stop unwinding the undo stack.
  )

(defun* jez-add-choice-point (state state-sym)
  "Add a choice point to STATE.  If STATE-SYM
is non-nil, put STATE-SYM on the and-stack when we backtrack
to this chioce point."
  (check-type state-sym symbol)
  (jez-with-slots (and-stack) (jez-state state)
    (jez-add-undo state
      (if state-sym (cons state-sym and-stack) and-stack)
      (point)
      #'jez--undo-handle-choice-point)))

(defun* jez-do-next (state next-state)
  "Add NEXT-STATE to STATE's and-stack; the next time JEZ-ADVANCE is called,
we'll try to match the state given by NEXT-STATE and if that
doesn't match, we'll backtrack."
  (check-type next-state symbol)
  (push next-state (jez-state--and-stack state)))

(defun* jez-state-finish-current (state)
  (pop (jez-state--and-stack state)))

(defun* jez-state-copy (state)
  "Return an independent copy of STATE."
  (jez--make-state
   :reach (jez-state--reach state)
   :or-stack (copy-sequence (jez-state--or-stack state))
   :or-stack-pos (jez-state--or-stack-pos state)
   :and-stack (jez-state--and-stack state)
   :ast (jez-state--ast state)))


;;; ----------------------------
;;; Intermediate representation.
;;; ----------------------------
;;;
;;; When we compile a grammar using JEZ-COMPILE, we first transform
;;; the input into a graph of jez-irn instances.  Each node represents
;;; a possible state our parser (or more specifically, the state of
;;; the jez-state object representing a particular parse) may take on
;;; during parsing.  Each potential state transition is an edge in
;;; this graph.
;;;
;;; Each node is associated with a Lisp function that, when called
;;; with a given jez-state instance, selects on appropriate transition
;;; and updates the jez-state accordingly.
;;;
;;; After building the parse-state graph, we apply transformations to
;;; simplify and optimize it.
;;;
;;; After optimizing the state graph, we walk all states reachable
;;; from the initial state, and for each one, we generate a unique
;;; symbol; to this symbol's function slot we assign a byte compiled
;;; state function responsible for implementing the action represented
;;; by the corresponding IR node.  (See below for details of the
;;; operation of these parse functions.)  We generate this function by
;;; calling JEZ-IRN-COMPILE on the IR node, which in turn calls the
;;; function given by the `compile-func' slot of the node instance.
;;;
;;; This final transformation allows us to transition from one state
;;; to the next via a simple FUNCALL, giving us maximum efficiency.
;;;
;;; Parsing Details
;;; ---------------
;;;
;;; The state machine embedded in a jez-state instance is essentially
;;; a backtracking pushdown automaton with two stacks: the and-stack
;;; and the or-stack.  The and-stack holds states that we plan to
;;; match in case of success; the or-stack holds a mixture of undo
;;; records and choice points.  When we advance a parse with
;;; JEZ-ADVANCE, we pop a state function off the and-stack and call
;;; it.  (A brand-new jez-state has one entry on its and-stack.)
;;;
;;; On success, the state function updates the parse state: any
;;; modification to the parse state other than pushing an item onto
;;; the and-stack (which should be done using JEZ-DO-NEXT) must be
;;; paired with an undo function pushed onto the or-stack using
;;; JEZ-ADD-UNDO.  When a parse can proceed in more than one way, the
;;; state function uses JEZ-ADD-CHOICE-POINT to make a note of this
;;; situation: if the parse selected using the chosen path fails, we
;;; instead try the path specified in the call to
;;; JEZ-ADD-CHOICE-POINT.  The top of the and-stack in the returned
;;; state is the new state of the parse.
;;;
;;; On failure, the state function calls JEZ-BACKTRACK on the input
;;; state and returns its result.  JEZ-BACKTRACK essentially returns
;;; to the state of the parse at the last call to
;;; JEZ-ADD-CHOICE-POINT.  Specifically, it pops entries from the
;;; or-stack, calling these entries to undo global state changes,
;;; until it's popped a choice point.  The choice point contains a new
;;; state to push on to the and-stack.
;;;
;;; N.B. All functions may destructively modify input parse states.
;;;
;;; Reach
;;; -----
;;;
;;; Each jez-state maintains a field called "reach" which holds the
;;; greatest buffer examined during the parse.  Unlike most other
;;; fields, reach is _not_ saved and restored during backtracking.
;;; Preserving it allows higher-level code to reliably cache jez-state
;;; instances so that only part of a buffer needs to be re-parsed
;;; after a modification.
;;;

(define-functional-struct
  (jez-irn
   (:conc-name jez-irn--)
   (:constructor nil)
   (:copier nil))
  "Abstract base for an IR node in a parse-state graph."

  ;; Function that builds a parse function for this IRN.  The return
  ;; value if this function must itself be a function of one argument,
  ;; which, when called with an existing jez-state instance, returns a
  ;; new jez-state.
  (compile-func nil :read-only t :type function))

(deftype jez-irn-list ()
  '(jez-list-of-type (or symbol jez-irn)))

(defun* jez-irn-compile (irn parser)
  "Return the state symbol for IRN.  The returned symbol's
function slot contains the symbol function for IRN.  If IRN has
not previously been compiled, do that during this call."
  (check-type irn jez-irn)
  (jez-with-slots (compile-func) (jez-irn irn)
    (jez-with-slots (node-names) (jez-parser parser)
      (or (gethash irn node-names)
          (let ((name (gensym "jez-irn")))
            (puthash irn name node-names)
            (fset name (funcall compile-func irn parser name))
            name)))))


;;; ------------
;;; Sequence IRN
;;; ------------

(define-functional-struct
  (jez-sequence
   (:conc-name jez-sequence--)
   (:constructor jez--%make-sequence)
   (:include jez-irn)
   (:copier nil))
  "IR node that matches a sequence of states."
  (pstates nil :read-only t :type jez-irn-list))

(defun* jez-sequence--compile (irn parser self)
  `(lambda (state)
     ,@(loop for irn in (reverse (jez-sequence--pstates irn))
             collect `(jez-do-next state ',(jez-irn-compile irn parser)))))

(defun* jez--make-sequence (states)
  "Make a jez-sequence instance."
  (jez--%make-sequence
   :compile-func #'jez-sequence--compile
   :pstates (jez-the jez-irn-list states)))


;;; ------------------
;;; Ordered choice IRN
;;; ------------------

(define-functional-struct
  (jez-ochoice
   (:conc-name jez-ochoice--)
   (:constructor jez--%make-ochoice)
   (:include jez-irn)
   (:copier nil))
  "IR node that tries matching each in a sequence of states."
  (choices nil :read-only t :type jez-irn-list))

(defun* jez-ochoice--compile (irn parser self)
  (jez-with-slots (choices) (jez-ochoice irn)
    (cond ((null choices)
           ;; Base case: always backtrack since we didn't match
           ;; anything.  (This state exists to make sure that there's
           ;; always a choice point saved when an ordered choice
           ;; succeeds, allowing users to use backtracking control to
           ;; kill it in all cases and freeing them from having to
           ;; make a special case out of the last choice point.)
           `(lambda (state)
              (jez-backtrack state)
              nil))
          (t
           ;; Try the first of our choices, and if that fails,
           ;; backtrack to an ordered choice of the rest of our
           ;; states.
           `(lambda (state)
              (jez-add-choice-point state
                                    ',(jez-irn-compile
                                       (jez--make-ochoice (cdr choices))
                                       parser))
              (jez-do-next state ',(jez-irn-compile (car choices) parser))
              )))))

(defun* jez--make-ochoice (states)
  "Make a jez-ochoice instance."
  (jez--%make-ochoice
   :compile-func #'jez-ochoice--compile
   :choices (jez-the jez-irn-list states)))


;;; --------------
;;; Repetition IRN
;;; --------------

(define-functional-struct
  (jez-repeat
   (:conc-name jez-repeat--)
   (:constructor jez--%make-repeat)
   (:include jez-irn)
   (:copier nil))
  "IR node that matches a given state zero or more times."
  (pstate nil :read-only t :type jez-irn))

(defun jez-repeat--compile (irn parser self)
  `(lambda (state)
     ;; If we're not successful below, return to whatever is next on
     ;; the and-stack. (N.B. matching zero elements counts as
     ;; success).
     (jez-add-choice-point state nil)

     ;; We first pop the and-stack and try to match the thing we're
     ;; trying to repeat.  If successful, we return to this state and
     ;; match over and over again.  We'll eventually run out of items
     ;; to match (either because we see a different item or because we
     ;; run out of tokens to parse) and go to the backtracking point
     ;; above.
     (jez-do-next state ',self)
     (jez-do-next state ',(jez-irn-compile (jez-repeat--pstate irn)
                                           parser))))

(defun* jez--make-repeat (state)
  "Make an IR node matching STATE zero or more times."
  (jez--%make-repeat
   :compile-func #'jez-repeat--compile
   :pstate (jez-the jez-irn state)))


;;; --------------------------
;;; Single-character match IRN
;;; --------------------------

(define-functional-struct
  (jez-char
   (:conc-name jez-char--)
   (:constructor jez--%make-char)
   (:include jez-irn)
   (:copier nil))
  "IR node that matches a single character in the buffer."
  (char nil :read-only t :type character))

(defun* jez-char--compile (irn parser self)
  `(lambda (state)
     (if (eql (char-after) ,(jez-char--char irn))
         (forward-char)
       (jez-backtrack state))))

(defun* jez--make-char (char)
  "Make an IR node matching a character."
  (jez--%make-char
   :compile-func #'jez-char--compile
   :char (jez-the character char)))


;;; ------------------------
;;; Special end-of-parse IRN
;;; ------------------------

(define-functional-struct
  (jez-end-state
   (:conc-name jez-end-state--)
   (:constructor jez--%make-end-state)
   (:include jez-irn)
   (:copier nil))
  "IR node that terminates a parse by resolving to itself
endlessly."
  (result nil :read-only t :type boolean))

(defun* jez-end-state--compile (irn parser self)
  `(lambda (state)
     (jez-do-next state ',self)
     ',(jez-end-state--result irn)))

(defun* jez--make-end-state (result)
  "Make a new IR node for an end state."
  (assert (memq result '(done fail)))
  (jez--%make-end-state
   :compile-func #'jez-end-state--compile
   :result result))


;;; ----------------------
;;; Semantic predicate IRN
;;; ----------------------

(define-functional-struct
  (jez-predicate
   (:conc-name jez-predicate--)
   (:constructor jez--%make-predicate)
   (:include jez-irn)
   (:copier nil))
  "IR that matches some predicate function."
  (predicate nil :read-only t))

(defun* jez-predicate--compile (irn parser self)
  "Compile a predicate."

  ;; N.B. we deliberately leak "state" into the lexical environment of
  ;; our predicate.

  `(lambda (state)
     (unless ,(jez-predicate--predicate irn)
       (jez-backtrack state))))

(defun* jez--make-predicate (predicate)
  "Make a new IR node for end-of-buffer."
  (jez--%make-predicate
   :compile-func #'jez-predicate--compile
   :predicate predicate))


;;; -------------------
;;; Semantic action IRN
;;; -------------------

(define-functional-struct
  (jez-action
   (:conc-name jez-action--)
   (:constructor jez--%make-action)
   (:include jez-irn)
   (:copier nil))
  "IR that matches some action function."

  ;; Form that's evaluated when we match.
  (action nil :read-only t))

(defun* jez-action--compile (irn parser self)
  "Compile an action."

  ;; Note that we deliberately leak "state" into the lexical
  ;; environment of our action.

  `(lambda (state)
     ,(jez-action--action irn)))

(defun* jez--make-action (action)
  "Make a new IR node for end-of-buffer."
  (jez--%make-action
   :compile-func #'jez-action--compile
   :action (jez-the list action)))


;;; ---------
;;; Optimizer
;;; ---------

(defun* jez--optimize (parser irn &optional seen)
  "Optmize IRN, which belongs to PARSER.  Return a new irn to use
in its place."

  ;; The `seen' variable holds references to nodes we've already
  ;; optimized, allowing us to avoid recursing endlessly when the
  ;; parse graph contains cycles.

  (let ((new-irn irn))

    (unless seen
      (setf seen (make-hash-table :test 'eq)))

    new-irn))


;;; -----------
;;; AST support
;;; -----------

(defun jez--restore-ast (state)
  (setf (jez-state--ast state)
        (jez-state-pop-undo state))
  nil)

(defun jez--push-ast-node (state kind)
  (let ((ast (jez-state--ast state)))
    ;; Restore the old ast if we ever roll back
    (jez-add-undo state
      ast
      #'jez--restore-ast)
    ;; Add a new node to the ast and make
    ;; it current.
    (setf (jez-state--ast state)
          (jez-tree-append-child
               ast
               (list 'begin (point)
                     'kind kind)))))

(defun jez--pop-ast-node (state)
  (setf (jez-state--ast state)
        (jez-tree-up
         (jez-tree-put
          (jez-state--ast state)
          'end (point)))))


;;; -------
;;; Parsing
;;; -------

(defun* jez--make-parser (top-irn)
  (let* ((parser (jez--%make-parser)))
    (jez-with-slots (initial-state) (jez-parser parser)
      (setf initial-state (jez--make-state))

      ;; If we try to backtrack past the last choice point, there is no
      ;; possible way to continue.  Arrange for jez-advance to
      ;; transition to a special state in this case: this special state
      ;; just fails forever.
      (jez-add-choice-point initial-state
                            (jez-irn-compile
                             (jez--make-end-state 'fail)
                             parser))

      ;; Similarly, after we're successfully parsed everything,
      ;; transition to a state that succeeds forever.
      (jez-do-next initial-state
                   (jez-irn-compile
                    (jez--make-end-state 'done)
                    parser))

      ;; Begin parsing in the initial state.
      (jez-do-next initial-state
                   (jez-irn-compile top-irn parser)))

    parser))

(defun* jez-begin-parse (parser)
  "Begin parsing using a state."
  (let ((new-state (jez-state-copy (jez-parser--initial-state parser))))
    (setf (jez-state--reach new-state) (point-min))
    new-state))

(defun* jez-advance (state)
  "Update parse state STATE.  Return the symbol `done' if we are
at the end of input, `fail' if we are at an error state, or nil
otherwise."
  (jez-with-slots (and-stack) (jez-state state)
    (assert and-stack)
    (funcall (pop and-stack) state)))


;;; ---
;;; End
;;; ---

(provide 'jezebel-engine)
